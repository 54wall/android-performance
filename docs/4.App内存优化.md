## 第4章 App内存优化

#### 4-2 内存优化介绍及工具选择

1. 内存优化介绍
   1. 内存是大问题但缺乏关注
   2. 压死骆驼的最后一根稻草
2. 内存问题
   1. 内存抖动：锯齿状、GC导致卡顿
   2. 内存泄漏：可用内存减少、频繁GC
   3. 内存溢出：OOM、程序异常
3. 优化工具选择
   1. Memory Profiler
      1. 实时图标展示应用内存使用量
      2. 识别内存泄漏、抖动等
      3. 提供捕获堆转储、强制GC以及跟踪内存分配的能力
      4. 方便直观、线下平时使用
   2. Memory Analyzer
      1. 强大的Java Heap分析工具，查找内存泄漏及内存占用
      2. 生成整体报告、分析问题等
      3. 线下深入使用
   3. LeakCanary
      1. 自动内存泄漏检测
      2. https://github.com/square/leakcanary
      3. 线下集成

#### 4-3 Android内存管理机制

1. Java内存管理机制

   1. Java内存分配

      1. 方法区、虚拟机栈、本地方法栈、堆、程序计数器

   2. Java内存回收算法

      1. 标记-清除算法

         效率和清除效率不高

         产生大量不连续的内存碎片

         1. 标记出所有需要回收的对象
         2. 统一回收所有被标记的对象

      2. 复制算法

         实现简单，运行高效

         浪费一半空间，代价大

         1. 将内存划分为大小相等的两块
         2. 一块内存用完之后复制存活对象到另一块
         3. 清理另一块内存

      3. 标记-整理算法

         1. 标记过程与“标记-清除”算法一样
         2. 存活对象往一端进行移动
         3. 清理其余内存

      4. 分代收集算法

         1. 结合多种收集算法优势
         2. 新生代对象存活率低，复制
         3. 老年代对象存活率高，标记-整理

2. Android内存管理机制

   内存弹性分配，分配值与最大值受具体设备影响

   OOM场景：内存真正不足、可用内存不足

   1. Dalvik与Art区别
      1. Dalvik仅固定一种回收算法
      2. Art回收算法可运行期选择
      3. Art具备内存整理能力，减少内存空洞
   2. Low Memory Killer
      1. 进程分类
      2. 回收收益

#### 4-4 内存抖动解决实战

1. 内存抖动介绍

   定义：内存频繁分配和回收导致内存不稳定

   表现：频繁GC、内存曲线呈锯齿状

   危害：导致卡顿、OOM

   内存抖动导致OOM：

   1. 频繁创建对象，导致内存不足及碎片
   2. 不连续的内存片无法被分配，导致OOM

2. 内存抖动解决实战

   1. 使用Memory Profiler初步排查
   2. 使用Memory Profiler或CPU Profiler结合代码排查
   3. 模拟内存抖动代码见：MemoryShakeActivity

3. 内存抖动解决技巧

   找循环或者频繁调用的地方

#### 4-5 内存泄露解决实战

1. 内存泄漏介绍

   定义：内存中存在已经没有用的对象

   表现：内存抖动、可用内存逐渐变少

   危害：内存不足、GC频繁、OOM

2. Memory Analyzer

   1. http://www.eclipse.org/mat/downloads.php
   2. 转换：hprof-conv原文件路径转换后文件路径
   3. 模拟内存泄露代码见：MemoryLeakActivity

3. 内存泄漏解决实战

   1. 使用Memory Profiler初步观察
   2. 使用Memory Analyzer结合代码确认
   3. 找到内存泄露位置

#### 4-6 全面理解MAT

#### 4-7 ARTHook优雅检测不合理图片

#### 4-8 线上内存监控方案

#### 4-9 内存优化技巧总结

#### 4-10 内存优化模拟面试